#!/usr/bin/env python2
from copy import copy
from optparse import Option, OptionParser, OptionValueError
from sys import argv, exit, stderr
from textwrap import TextWrapper
from urllib2 import urlopen
from BeautifulSoup import BeautifulSoup


I = ' ' * 4
text_wrap = TextWrapper(initial_indent=I, subsequent_indent=I, fix_sentence_endings=True)
base_url = 'http://www.etymonline.com/index.php?search=%(word)s&searchmode=%(mode)s'
mode_map = {
    'natural':('Natural language', 'nl'),
    'single':('Single term', 'term'),
    'any':('Any term', 'or'),
    'phrase':('Exact phrase', 'phrase'),
    'search':('Search mode', 'none'),
    }


def check_mode(option, opt, value):
    try:
        return mode_map[value][1]
    except (KeyError, ):
        raise OptionValueError('Option %s: invalid mode: %s' % (opt, value))


class ModeOption(Option):
    TYPES = Option.TYPES + ('mode', )
    TYPE_CHECKER = copy(Option.TYPE_CHECKER)
    TYPE_CHECKER['mode'] = check_mode


def get_options(args=None):
    usage = 'Usage: %prog [options] WORD [WORD...]'
    parser = OptionParser(usage=usage, option_class=ModeOption)
    add = parser.add_option
    add('-m', '--mode', dest='mode', default='search', type='mode',
        help='Search mode.')
    add('', '--help-modes', dest='help_modes', action='store_true', default=False,
        help='Show search modes.')
    opts, args = parser.parse_args(argv if args is None else args)
    return parser, opts, args


def main(mode, words):
    result = len(words)
    for word in words:
        url = base_url % dict(word=word, mode=mode)
        soup = BeautifulSoup(urlopen(url))
        dictdiv = soup.find('div', id='dictionary')
        items = zip(dictdiv.findAll('dt'), dictdiv.findAll('dd'))
        if not items:
            print >> stderr, 'Word not found: %s' % (word, )
        else:
            print '== Online Etymology Dictionary Entry for "%s"' % (word, )
            print '== Source: %s \n' % (url, )
            result -= 1
        for term, defn in items:
            deftext = ' '.join(defn.findAll(text=True))
            print term.find(text=True)
            print '\n'.join(text_wrap.wrap(deftext))
            print
    return result


def show_modes(parser):
    default = parser.get_option('-m').default
    print 'Search modes:'
    for k, (t, m) in sorted(mode_map.items()):
        print '    %s=%s' % (k, t + (' (default)' if m==default else ''))


if __name__ == '__main__':
    parser, opts, args = get_options()
    if opts.help_modes:
        show_modes(parser)
        exit(1)
    else:
        exit(main(opts.mode, args[1:]))
